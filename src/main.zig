const std = @import("std");
const Allocator = std.mem.Allocator;
const c = @import("c.zig");
const Window = @import("window.zig").Window;
const gl = @import("gl_4v3.zig");
const gfx = @import("graphics.zig");
const math = @import("math.zig");
const vec2 = math.vec2;
const vec4 = math.vec4;
const Font = @import("Font.zig");
const UiContext = @import("UiContext.zig");
const Size = UiContext.Size;

const encabulator =
    \\Here, at Rockwell Automation's World Headquarters, research has been proceding to develop a line of automation products that establishes new standards for quality, technological leadership, and operating excellence.
    \\With customer success as our primary focus, work has been proceeding on the crudely conceived idea of an instrument that would not only provide inverse reactive current, for use in unilateral phase detractors, but would also be capable of automatically synchronizing cardinal gram meters.
    \\Such an instrument, comprised of Dodge gears and bearings, Reliance Electric motors, Allen-Bradley controls, and all monitored by Rockwell Software, is Rockwell Automation's Retro Encabulator.
    \\
    \\Now, basically, the only new principle involved is that instead of power being generated by the relative motion of conductors and fluxes, it's produced by the modial interation of magneto reluctance, and capacitive duractants.
    \\The original machine had a baseplate of prefamulated amulite, surmounted by a malleable logarithmic casing in such a way that the two sperving bearings ran a direct line through the panametric fam.
    \\The line-up consisted, simply, of six hydrocoptic marzal veins, so fitted to the ambiphasient lunar waneshaft that side fumbling was effectively prevented.
    \\The main winding was of the Lotus odeltoid type, placed in panendermic semi-boloid slots of the stater, every seventh conductor being connected by a non-reversible tremipipe to the differential Gerdle spring on the up end of the gram meter.
    \\
    \\Moreover, whenever florescent square motion is required, it may also be employed in conjunction with a drawn reciprocation dangle arm to reduce sinosoyal deplanaration. The Retro Encabulator has now reached a high level of development, and it's being successfully used in the operation of Milford trenyeds.
    \\It's available soon, wherever Rockwell Automation products are sold.
;

pub fn main() !void {
    var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{
        .stack_trace_frames = 8,
        .enable_memory_limit = true,
    }){};
    defer _ = general_purpose_allocator.detectLeaks();
    const allocator = general_purpose_allocator.allocator();

    var width: u32 = 1000;
    var height: u32 = 600;
    // setup GLFW
    var window = Window.init(allocator, width, height, "pestctl");
    window.setup_callbacks();
    defer window.deinit();
    // setup OpenGL
    try gl.load(window.handle, get_proc_address_fn);
    gl.enable(gl.DEBUG_OUTPUT);
    gl.debugMessageCallback(gl_error_callback, null);
    //std.log.info("{s}", .{gl.getString(gl.VERSION).?});

    // GL state that we never change
    gl.clearColor(0.75, 0.36, 0.38, 1);
    gl.enable(gl.CULL_FACE);
    gl.enable(gl.BLEND);
    gl.blendFunc(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA);
    gl.enable(gl.DEPTH_TEST);
    gl.depthFunc(gl.LEQUAL);
    gl.enable(gl.LINE_SMOOTH);

    var ui = try UiContext.init(allocator, "VictorMono-Regular.ttf", &window);
    defer ui.deinit();

    var last_mouse_pos = vec2{ 0, 0 };
    var last_time = @floatCast(f32, c.glfwGetTime());

    var backing_buf: [0x1000]u8 = undefined;
    var text_buf: []u8 = &backing_buf;
    text_buf.len = 0;

    while (!window.should_close()) {
        window.framebuffer_size(&width, &height);
        gl.viewport(0, 0, @intCast(i32, width), @intCast(i32, height));
        //const ratio = @intToFloat(f32, width) / @intToFloat(f32, height);

        const cur_time = @floatCast(f32, c.glfwGetTime());
        const dt = cur_time - last_time;
        last_time = cur_time;

        const mouse_pos = window.mouse_pos();
        //var mouse_diff = mouse_pos - last_mouse_pos;
        last_mouse_pos = mouse_pos;

        const mouse_pos_ui = vec2{ mouse_pos[0], @intToFloat(f32, height) - mouse_pos[1] };
        try ui.startFrame(width, height, mouse_pos_ui, &window.event_queue);

        while (window.event_queue.next()) |event| {
            _ = event;
        }

        //const parent_size = [2]Size{ Size.pixels(100, 1), Size.by_children(1) };
        //const parent_color = vec4{ 0, 0, 0, 1 };
        //const parent = ui.addNode(.{ .draw_border = true, .draw_background = true }, "test_parent", .{
        //    .bg_color = parent_color,
        //    .pref_size = parent_size,
        //    .child_layout_axis = .y,
        //});
        //ui.pushParent(parent);
        //if (ui.button("The missile knows where it is, because it knows where it isn't.").clicked) std.debug.print("missile\n", .{});
        //_ = ui.label("lol lmao");

        ui.pushStyle(.{ .bg_color = vec4{ 0.75, 0.75, 0.75, 1 } });
        _ = ui.textInput("textinput", &backing_buf, &text_buf.len);
        _ = ui.popStyle();

        //_ = ui.popParent();

        //_ = ui.spacer(.y, Size.percent(1, 0));
        //_ = ui.labelF("hot_key=0x{x}, active_key=0x{x}###ui info label", .{ ui.hot_node_key, ui.active_node_key });

        gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
        try ui.render();

        ui.endFrame(dt);
        window.update();
    }

    std.debug.print("final buf:\n{}\n", .{std.fmt.fmtSliceEscapeLower(text_buf)});
}

fn get_proc_address_fn(window: ?*c.GLFWwindow, proc_name: [:0]const u8) ?*const anyopaque {
    _ = window;
    const fn_ptr = c.glfwGetProcAddress(proc_name);
    // without this I got a "cast discards const qualifier" error
    return @intToPtr(?*opaque {}, @ptrToInt(fn_ptr));
}

fn gl_error_callback(source: u32, error_type: u32, id: u32, severity: u32, len: i32, msg: [*:0]const u8, user_param: ?*const anyopaque) callconv(.C) void {
    _ = len;
    _ = user_param;

    if (severity == gl.DEBUG_SEVERITY_NOTIFICATION) return;

    const source_str = switch (source) {
        0x824B => "SOURCE_OTHER",
        0x824A => "SOURCE_APPLICATION",
        0x8249 => "SOURCE_THIRD_PARTY",
        0x8248 => "SOURCE_SHADER_COMPILER",
        0x8247 => "SOURCE_WINDOW_SYSTEM",
        0x8246 => "SOURCE_API",
        else => unreachable,
    };
    const error_type_str = switch (error_type) {
        0x826A => "TYPE_POP_GROUP",
        0x8269 => "TYPE_PUSH_GROUP",
        0x8268 => "TYPE_MARKER",
        0x8251 => "TYPE_OTHER",
        0x8250 => "TYPE_PERFORMANCE",
        0x824F => "TYPE_PORTABILITY",
        0x824E => "TYPE_UNDEFINED_BEHAVIOR",
        0x824D => "TYPE_DEPRECATED_BEHAVIOR",
        0x824C => "TYPE_ERROR",
        else => unreachable,
    };
    const severity_str = switch (severity) {
        0x826B => "SEVERITY_NOTIFICATION",
        0x9148 => "SEVERITY_LOW",
        0x9147 => "SEVERITY_MEDIUM",
        0x9146 => "SEVERITY_HIGH",
        else => unreachable,
    };
    std.log.info("OpenGL: ({s}, {s}, {s}, id={}) {s}", .{ source_str, severity_str, error_type_str, id, msg });
}
